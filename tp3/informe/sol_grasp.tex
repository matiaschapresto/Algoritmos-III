\section{Metaheuristica GRASP: Solucion propuesta}

Dado que la heur\'istica GRASP es una combinaci\'on entre una heur\'istica golosa aleatorizada y una b\'usqueda local, decidimos utilizar nuestras heur\'isticas previamente mencionadas, con algunas modificaciones.

\subsubsection{Modificaci\'on a la heur\'istica golosa}

\vspace{2mm}

Durante el ciclo del algoritmo goloso, recordemos que la primera instrucci\'on del ciclo principal, al igual que el algoritmo de Dijkstra, es obtener el m\'inimo nodo de la cola segu\'un $w_2$. En lugar de esto, ahora armamos una lista restringida de canditatos, o RCL. El algoritmo ahora tiene dos par\'ametros, $tipo\_ejecucion$ que indica tres tipos de ejecuci\'on: determin\'istico, por valor y por cantidad, y un par\'ametro $\beta$. El tipo determin\'istico es an\'alogo a la heur\'istica golosa antes descripta, simplemente tomando el m\'inimo y el par\'ametro $\beta$ es ignorado.

\vspace{2mm}

El tipo de ejecuci\'on por valor arma una lista de candidatos filtrados por su valor, seg\'un un porcentaje de alejamiento del valor del m\'inimo, indicado por el par\'ametro $\beta$. Es decir, se toma la cola y se filtran los candidatos factibles cuyo valor sobrepase $(\beta + 1)*valor\_del\_minimo$). Luego se elige al azar uno de los candidatos.

\vspace{2mm}

El tipo de ejecuci\'on por cantidad se basa en tomar la cola, y tomar los $\beta$ nodos de valor m\'inimo. Luego se elige uno al azar. Como la cola est\'a ordenada, cumple la condici\'on de RCL por cantidad, con lo que basta tomar un n\'umero aleatorio $i$ entre $0$ y  $min\{cola.size(), parametro\_beta\} -1$ y devolver el $i$-\'esimo elemento de la cola.

\vspace{2mm}

\begin{algorithmic}

\While{ $ !cola=\emptyset$ }
	\If{$tipo\_ejecucion == deterministico$}
    	 \State $nodo \: minimo = minimo(cola)$    
    \ElsIf{$tipo\_ejecucion == por\_cantidad$}
		\State $int \: random = random(0, min\{cola.size(), parametro\_beta\} -1)$
		\State $ \: minimo = cola[random]$
	\ElsIf{$tipo_ejecucion == por\_valor$}
		\State $lista \: nodo \: candidatos = \emptyset$
		\State $int \: i = 0$
		\While{$i<tamano(cola)$}
			\If{$ cola[i] \leq valor\_limite $}
				\State $ agregar(cola[i], candidatos) $
			\EndIf
		\EndWhile
		\State $int \: random = random(0, min\{cola.size(), parametro\_beta\} -1)$
		\State $ \: minimo = candidatos[random]$
		\EndIf
		
\EndWhile
\end{algorithmic}

\vspace{2mm}

No fue necesario realizar modificaciones a la heur\'istica de b\'usqueda local.

\subsection{Critero de terminaci\'on}

Fijada ya la heur\'istica golosa aleatorizada, y la heur\'istica de b\'usqueda local, queda definir por el criterio de terminaci\'on.


\vspace{2mm}

Hay tres criterios implementados:

\begin{enumerate}
\item Cantidad de iteraciones l\'imite (fijo o variable)
\item Cantidad de iteraciones sin mejora
\item Soluci\'on suficientemente buena
\end{enumerate}

Cantidad de iteraciones l\'imite, como su nombre lo indica itera hasta un l\'imite dado, ya sea una constante, o una variable del problema, por ejemplo la cantidad de nodos del grafo. Cantidad iteraciones sin mejora corta la iteraci\'on cuando se haya alcanzado una cantidad de iteraciones m\'inimas sin que haya habido alguna mejora en el camino.

\vspace{2mm}

Soluci\'on suficientemente buena corta la iteraci\'on cuando considere que la soluci\'on obtenida por la \'ultima iteraci\'on, si bien puede o no ser la \'optima, alcanza para los requerimientos del problema. Generalmente s\'olo tiene sentido si puede conocerse alguna cota de optimalidad para la instancia, de forma de poder comparar la soluci\'on parcial con ella y poder determinar su calidad. No vamos a utilizarla en nuestro caso ya que nuestra heur\'istica no posee forma de conocer esto, fue implementada por cuestiones de experimentaci\'on.

\vspace{2mm}

\subsection{Pseudoc\'odigo}

Nota: la entrada $criterios$ se refiere a las variables:

\begin{enumerate}
\item $tipo\_golosa$ : el tipo de ejecuci\'on para la parte golosa.
\item $tipo\_bq$ : el tipo de ejecuci\'on para la b\'usqueda local
\item $\beta$ : el par\'ametro para armar la RCL de la parte golosa.
\item $citerio\_terminacion$ : el criterio de terminaci\'on de GRASP.
\item $max\_its$ : la cantidad de iteraciones l\'mite del primer criterio de terminaci\'on.
\item $max\_its\_sin\ _mejora$ : la cantidad de iteraciones en la cual el segundo criterio debe cortar el algoritmo sin obtener mejora.
\item $ valor\_suficiente $: el valor que sirve como criterio para determinar si una soluci\'on parcial es lo suficientemente buena para terminar el algoritmo (tercer criterio).
\end{enumerate}

\begin{algorithmic}

\Procedure{$Sol\_GRASP$}{$Grafo\: g, \:vertice\: v_1,\: vertice \: v_2, \: int \: k, criterios$}{$\rightarrow lista<eje>\: camino$}

	\Statex
	\State $bool \: condicion\_terminacion\: =\: false$
    \State $lista<eje> \:mejor\_solucion\: = \emptyset$
    \State $int \:costo\_mejor\_solucion\: =\: \inf$
    \State $lista<eje> \:camino\: = \emptyset$
    \State $int\: cant\_iters \:= \:0$
    \State $int\: cant\_iters\_sin\_mejora \:= 0$

    \While{$!condicion\_terminacion$}

    	\State $camino\: =\: solucion\_golosa(g, tipo\_golosa, \beta)$
    	\While{$se \: puede \: mejorar \: camino$}
    			\State $camino = busqueda\_local(g, tipo\_bq)$
    	\EndWhile

    	\State $ int \:  costo\_sol\_actual \: = \: costo\_w_2(camino)$

		\If{$costo\_sol\_actual < costo\_mejor\_solucion$}

            \State $costo\_mejor\_solucion = costo\_sol\_actual$
            \State $mejor\_solucion = camino$
            
            \State $cant\_iters\_sin\_mejora = 0$
        \Else
            
            \State $cant\_iters\_sin\_mejora++$
        \EndIf

        \State $cant\_iters++$
    

    \If{$criterio\_terminacion == 1$}
           \State $condicion\_terminacion = (cant\_iters < max\_its)$            
        \ElsIf{$criterio\_terminacion == 2$}
            \State $condicion_terminacion = (cant\_iters\_sin\_mejora < max\_its\_sin\ _mejora)$
        \ElsIf{$criterio\_terminacion == 3$}
            \State $condicion\_terminacion = (costo\_mejor\_solucion < valor\_suficiente)$
        \EndIf

       \EndWhile

       \State $return\:  mejor\_solucion$

\EndProcedure
\end{algorithmic}
