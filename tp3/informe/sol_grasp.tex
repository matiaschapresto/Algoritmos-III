\section{Metaheuristica GRASP: Solucion propuesta}

Dado que la heur\'istica GRASP es una combinaci\'on entre una heur\'istica golosa aleatorizada y una b\'usqueda local, decidimos utilizar nuestras heur\'isticas previamente mencionadas, con algunas modificaciones.

\subsubsection{Modificaci\'on a la heur\'istica golosa}

\vspace{2mm}

Durante el ciclo del algoritmo goloso, recordemos que la primera instrucci\'on era pedir la lista de incidentes del nodo actual. En lugar de esto, ahora armamos su lista restringida de canditatos, o RCL. El algoritmo ahora dos par\'ametros, $tipo\_ejecucion$ que indica tres tipos de ejecuci\'on: determin\'istico, por valor y por cantidad, y un par\'ametro $\beta$. El tipo determin\'istico es an\'alogo a la heur\'istica golosa antes descripta, y el par\'ametro $\beta$ es ignorado.

\vspace{2mm}

El tipo de ejecuci\'on por valor arma una lista de candidatos filtrados por su valor, seg\'un un porcentaje de alejamiento del valor del m\'inimo, indicado por el par\'ametro $\beta$. Es decir, se filtran los candidatos factibles cuyo valor sobrepase $(\beta + 1)*valor\_del\_minimo$).

\vspace{2mm}

El tipo de ejecuci\'on por cantidad toma la lista ordenada de candidatos, y toma los $\beta$ mejores candidatos.

\vspace{2mm}

\begin{algorithmic}

\While{ $ actual != v_2 \: || \: RCL= \emptyset $ }
	\State $ list<eje> \: RCL = obtenerRCL(v_{actual}, g, tipo\_ejecucion, \beta) $
	\If{$tipo\_ejecucion == deterministico$}
    		 \State $eje \: minimo = cabeza(RCL)$    
    		 \ElsIf{$tipo\_ejecucion == por\_valor || tipo_ejecucion == por\_cantidad$}
			\State $int \: random = random(0 - long(RCL))$
			\State $eje \: minimo = candidatos[random]$
	\EndIf
	\State $ Agregar(minimo, camino) $
	\State $ costoCamino \: += costo1(minimo) $
	\State $ v_{actual} = v $
	\State $distanciaLlegada--$
\EndWhile
\State $ return \: camino $
\end{algorithmic}

La funci\'on $obtenerRCL$ arma lista restringida de candidatos tomando la lista aristas incidentes, eliminando aquellas en las que la distancia en saltos no es menor estricta, eliminando aquellas que no pertenecen a un camino v\'alido de costo $w_1$ menor a $K$, orden\'andola de menor a mayor seg\'un costo $w_2$ y aplicando los filtros anteriormente mencionados.

\vspace{2mm}

Acto seguido, si la ejecuci\'on es determin\'istica, simplemente se toma la cabeza de la RCL, que es el m\'inimo seg\'un costo $w_1$ de las aristas v\'alidas, lo cual es an\'alogo a la heur\'istica golosa sin modificaciones. En caso estar utilizando alg\'un otro tipo de ejecuci\'n, se genera un n\'umero aleatorio entre 0 y la longitud de RCL y se toma un elemento de RCL aleatorio. Aqu\'i se encuentra la aleatorizaci\'on del algoritmo goloso, tomando una arista v\'alida que forma parte de una subsoluci\'on posible, pero no tomando el m\'inimo siempre determin\'isticamente.

\vspace{2mm}

No fue necesario realizar modificaciones a la heur\'istica de b\'usqueda local.

\subsection{Critero de terminaci\'on}

Fijada ya la heur\'istica golosa aleatorizada, y la heur\'istica de b\'usqueda local, queda definir por el criterio de terminaci\'on.


\vspace{2mm}

Hay tres criterios implementados:

\begin{enumerate}
\item Cantidad de iteraciones l\'imite (fijo o variable)
\item Cantidad de iteraciones sin mejora
\item Soluci\'on suficientemente buena
\end{enumerate}

Cantidad de iteraciones l\'imite, como su nombre lo indica itera hasta un l\'imite dado, ya sea una constante, o una variable del problema, por ejemplo la cantidad de nodos del grafo. Cantidad iteraciones sin mejora corta la iteraci\'on cuando se haya alcanzado una cantidad de iteraciones m\'inimas sin que haya habido alguna mejora en el camino.

\vspace{2mm}

Soluci\'on suficientemente buena corta la iteraci\'on cuando considere que la soluci\'on obtenida por la \'ultima iteraci\'on, si bien puede o no ser la \'optima, alcanza para los requerimientos del problema. Generalmente s\'olo tiene sentido si puede conocerse alguna cota de optimalidad para la instancia, de forma de poder comparar la soluci\'on parcial con ella y poder determinar su calidad. No vamos a utilizarla en nuestro caso ya que nuestra heur\'istica no posee forma de conocer esto, fue implementada por cuestiones de experimentaci\'on.

\vspace{2mm}

El criterio utilizado en la experimentaci\'on es el nene, porque piolon.

\subsection{Pseudoc\'odigo}

Nota: la entrada $criterios$ se refiere a las variables:

\begin{enumerate}
\item $tipo\_golosa$ : el tipo de ejecuci\'on para la parte golosa.
\item $tipo\_bq$ : el tipo de ejecuci\'on para la b\'usqueda local
\item $\beta$ : el par\'ametro para armar la RCL de la parte golosa.
\item $citerio\_terminacion$ : el criterio de terminaci\'on de GRASP.
\item $max\_its$ : la cantidad de iteraciones l\'mite del primer criterio de terminaci\'on.
\item $max\_its\_sin\ _mejora$ : la cantidad de iteraciones en la cual el segundo criterio debe cortar el algoritmo sin obtener mejora.
\item $ valor\_suficiente $: el valor que sirve como criterio para determinar si una soluci\'on parcial es lo suficientemente buena para terminar el algoritmo (tercer criterio).
\end{enumerate}

\begin{algorithmic}

\Procedure{$Sol\_GRASP$}{$Grafo\: g, \:vertice\: v_1,\: vertice \: v_2, \: int \: k, criterios$}{$\rightarrow lista<eje>\: camino$}

	\Statex
	\State $bool \: condicion\_terminacion\: =\: false$
    \State $lista<eje> \:mejor\_solucion\: = \emptyset$
    \State $int \:costo\_mejor\_solucion\: =\: \inf$
    \State $lista<eje> \:camino\: = \emptyset$
    \State $int\: cant\_iters \:= \:0$
    \State $int\: cant\_iters\_sin\_mejora \:= 0$

    \While{$!condicion\_terminacion$}

    	\State $camino\: =\: solucion\_golosa(g, tipo\_golosa, \beta)$
    	\While{$se \: puede \: mejorar \: camino$}
    			\State $camino = busqueda\_local(g, tipo\_bq)$
    	\EndWhile

    	\State $ int \:  costo\_sol\_actual \: = \: costo\_w_2(camino)$

		\If{$costo\_sol\_actual < costo\_mejor\_solucion$}

            \State $costo\_mejor\_solucion = costo\_sol\_actual$
            \State $mejor\_solucion = camino$
            
            \State $cant\_iters\_sin\_mejora = 0$
        \Else
            
            \State $cant\_iters\_sin\_mejora++$
        \EndIf

        \State $cant\_iters++$
    

    \If{$criterio\_terminacion == 1$}
           \State $condicion\_terminacion = (cant\_iters < max\_its)$            
        \ElsIf{$criterio\_terminacion == 2$}
            \State $condicion_terminacion = (cant\_iters\_sin\_mejora < max\_its\_sin\ _mejora)$
        \ElsIf{$criterio\_terminacion == 3$}
            \State $condicion\_terminacion = (costo\_mejor\_solucion < valor\_suficiente)$
        \EndIf

       \EndWhile

       \State $return\:  mejor\_solucion$

\EndProcedure
\end{algorithmic}
