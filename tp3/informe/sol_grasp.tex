\section{Metaheuristica GRASP: Solucion propuesta}

Dado que la heur\'istica GRASP es una combinaci\'on entre una heur\'istica golosa aleatorizada y una b\'usqueda local, decidimos utilizar nuestras heur\'isticas previamente mencionadas, con algunas modificaciones.

\subsection{Modificaci\'on a la heur\'istica golosa}

\vspace{2mm}

Durante el ciclo del algoritmo goloso, recordemos que la primera instrucci\'on del ciclo principal, al igual que el algoritmo de Dijkstra, es obtener el m\'inimo nodo de la cola segu\'un $w_2$. En lugar de esto, ahora armamos una lista restringida de canditatos, o RCL. El algoritmo ahora tiene dos par\'ametros, $tipo\_ejecucion$ que indica tres tipos de ejecuci\'on: determin\'istico, por valor y por cantidad, y un par\'ametro $\beta$. El tipo determin\'istico es an\'alogo a la heur\'istica golosa antes descripta, simplemente tomando el m\'inimo y el par\'ametro $\beta$ es ignorado.

\vspace{2mm}

El tipo de ejecuci\'on por valor arma una lista de candidatos filtrados por su valor, seg\'un un porcentaje de alejamiento del valor del m\'inimo, indicado por el par\'ametro $\beta$. Es decir, se toma la cola y se filtran los candidatos factibles cuyo valor sobrepase $(\beta + 1)*valor\_del\_minimo$). Luego se elige al azar uno de los candidatos. 
\vspace{2mm}

El tipo de ejecuci\'on por cantidad se basa en tomar la cola, y tomar los $\beta$ nodos de valor m\'inimo. Luego se elige uno al azar. Como la cola est\'a ordenada, cumple la condici\'on de RCL por cantidad, con lo que basta tomar un n\'umero aleatorio $i$ entre $0$ y  $min\{cola.size(), parametro\_beta\} -1$ y devolver el $i$-\'esimo elemento de la cola.

\vspace{2mm}

Por otro lado, el invariante de Dijkstra nos asegura que tomando el mínimo en cada iteraci\'on, podemos sacarlo de la cola y estar seguros de que no volverá a ser actualizado (por principio de optimalidad de Bellman aplicado a caminos m\'inimos). El hecho tomar uno aleatorio no nos asegura esto, por lo tanto cada nodo puede ser visitado y encolado más de una vez. En particular cada nodo es encolado tantas veces como pueda ser mejorado por todos sus vecinos, y sin tener alguna tabla de nodos visitados, el algoritmo itera hasta no poder mejorar m\'as ning\'un nodo, momento en el que se vaci\'a la cola y de esa forma llega a la soluci\'on golosa determin\'istica. Notamos esto prematuramente en la experimentaci\'on al obtener resultados id\'enticos entre la heur\'stica golosa normal y aleatorizada en absolutamente todos los casos y decidimos solucionarlo marcando cada vez que un nodo ingresa en la cola de prioridad y restringirlo a una sola vez, mediante un $vector<bool>$. De esta forma nos aseguramos de esto, y una vez implementada esta mejora, comenzamos a obtener soluciones distintas entre ambos algoritmos, y pudimos ver distintos resultados al variar el par\'ametro $\betha$ (mientras m\'as pequeño, m\'as cercano al resultado determin\'stico), que mostraremos en la secci\'on de experimentaci\'on.
\begin{algorithmic}

\While{ $ !cola=\emptyset$ }
	\If{$tipo\_ejecucion == deterministico$}
    	 \State $nodo \: minimo = minimo(cola)$    
    \ElsIf{$tipo\_ejecucion == por\_cantidad$}
		\State $int \: random = random(0, min\{cola.size(), parametro\_beta\} -1)$
		\State $ \: minimo = cola[random]$
		\Comment $O(random)$, no es iterador de acceso aleatorio
	\ElsIf{$tipo_ejecucion == por\_valor$}
		\State $lista \: nodo \: candidatos = \emptyset$
		\State $int \: i = 0$
		\While{$i<tamano(cola)$}
			\If{$ cola[i] \leq valor\_limite $}
				\State $ agregar(cola[i], candidatos) $
			\EndIf
		\EndWhile
		\State $int \: random = random(0, min\{cola.size(), parametro\_beta\} -1)$
		\State $ \: minimo = candidatos[random]$
		\State $visitados[minimo] = true$
		\EndIf
		
\EndWhile
\end{algorithmic}

\vspace{2mm}

No fue necesario realizar modificaciones a la heur\'istica de b\'usqueda local.

\subsection{Critero de terminaci\'on}

Fijada ya la heur\'istica golosa aleatorizada, y la heur\'istica de b\'usqueda local, queda definir por el criterio de terminaci\'on.

\vspace{2mm}

Hay dos criterios implementados:

\begin{enumerate}
\item Cantidad de iteraciones l\'imite (fijo o variable)
\item Cantidad de iteraciones sin mejora
\end{enumerate}

Cantidad de iteraciones l\'imite, como su nombre lo indica itera hasta un l\'imite dado, ya sea una constante, o una variable del problema, por ejemplo la cantidad de nodos del grafo. Cantidad iteraciones sin mejora corta la iteraci\'on cuando se haya alcanzado una cantidad de iteraciones m\'inimas sin que haya habido alguna mejora en el camino.

\vspace{2mm}

\subsection{Consideraciones}

Dada la naturaleza aleatoria de la heur\'istica greedy aleatorizada, en una cantidad de casos despreciable en cuanto al total de experimentos (pero aun as\'i, ocurrieron), la heur\'istica, a\'un habiendo un camino factible en el grafo, no pudo proporcionar una soluci\'on. Por esto, decidimos validar la soluci\'on obtenida del algoritmo goloso, y en caso de que no sea v\'alida, ejecutarlo nuevamente hasta llegar a un tope de iteraciones fijo. Superado este tope de iteraciones, ajustamos el par\'ametro $\beta$ de GRASP, en el caso de que la b\'usqueda golosa sea por cantidad, lo decrementamos en $1$, en el caso por valor, simplemente lo fijamos en $0$ lo cual equivale a la b\'uqueda golosa determin\'istica.

\subsection{Pseudoc\'odigo}

Nota: la entrada $criterios$ se refiere a las variables:

\begin{enumerate}
\item $tipo\_golosa$ : el tipo de ejecuci\'on para la parte golosa.
\item $tipo\_bq$ : el tipo de ejecuci\'on para la b\'usqueda local
\item $\beta$ : el par\'ametro para armar la RCL de la parte golosa.
\item $citerio\_terminacion$ : el criterio de terminaci\'on de GRASP.
\item $max\_its$ : la cantidad de iteraciones l\'mite del primer criterio de terminaci\'on.
\item $max\_its\_sin\ _mejora$ : la cantidad de iteraciones en la cual el segundo criterio debe cortar el algoritmo sin obtener mejora.
\item $bad\_rgreedy\_its$ : la cantidad de iteraciones consecutivas para las cuales corremos la heur\'istica golosa aleatorizada hasta que de una soluci\'on factible.
\end{enumerate}

\begin{algorithmic}[1]

\Procedure{$Sol\_GRASP$}{$Grafo\: g, \:vertice\: v_1,\: vertice \: v_2, \: int \: k, criterios$}{$\rightarrow lista<eje>\: camino$}

	\Statex
	\State $bool \: condicion\_terminacion\: =\: false$
    \State $lista<eje> \:mejor\_solucion\: = \emptyset$
    \State $int \:costo\_mejor\_solucion\: =\: \inf$
    \State $lista<eje> \:camino\: = \emptyset$
    \State $int\: cant\_iters \:= \:0$
    \State $int\: cant\_iters\_sin\_mejora \:= 0$
    \State $int\: cant\_iters\_sin\_sol\_rgreedy\_factible = 0$
    \State $ bool\: sol\_valida\_rgreedy\: =\: false $
    \State $vector<pair<int, costo> > \: mejora\_iters\_grasp$
    \Statex 

    \While{$!condicion\_terminacion$}

    	\State $camino\: =\: solucion\_golosa(g, v_1,v_2, tipo\_golosa, \beta)$
    	\State $ sol\_valida\_rgreedy= validar\_solucion(camino)$
    	\Comment{Obtenemos solucion greedy}

    	\Statex
    	\If{$hay solucion$}
    		\If{$sol\_valida\_rgreedy$}
    		\Comment{Validamos si es factible}
	
	    			\State $cant\_iters\_sin\_sol\_rgreedy\_factible = 0$
	
	    			\State $int\: mejora\_iteracion\_actual\: = 0$
	        	    \State $int\: cant\_iters\_bqlocal\: = 0$
	
	        	    \Statex
	
	    			\While{$mejora\_iteracion\_actual > 0$}
	    					\Comment{Aplicamos Busqueda Local}
	    					\State $mejora\_iteracion\_actual=busqueda\_local(g, tipo\_bq, camino)$
	    					\State $cant\_iters\_bqlocal++$
	
	    			\EndWhile
	
	    			\State $ int \:  costo\_sol\_actual \: = \: costo\_w_2(camino)$
	
	    			\Statex
	
					\If{$costo\_sol\_actual < costo\_mejor\_solucion$}
					\Comment{Reemplazamos si es mejor solucion}
	
						\If{$cant\_iters>0$}
							\State $ agregar(mejora\_iters\_grasp, par<cant\_iters, costo\_mejor\_solucion - costo\_solucion\_actual>) $
						\EndIf
	        	    	\State $costo\_mejor\_solucion = costo\_sol\_actual$
	        	    	\State $mejor\_solucion = camino$
	        	    
	        	   	    \State $cant\_iters\_sin\_mejora = 0$
	        		\Else
	        			\If{$cant\_iters>0$}
	        				\State $ agregar(mejora\_iters\_grasp, par<cant\_iters, 0)>) $
	        	        \EndIf
	        	        \State $cant\_iters\_sin\_mejora++$
	        	    
	        	    	
	        	\EndIf
	
	        	\State $cant\_iters++$
	    	
	    	    	\Else
	    	    	\Comment{$sol\_valida\_rgreedy = false$}
	    	    	\State $cant\_iters\_sin\_sol\_greedy\_rand\_factible++$
	    	    	\If{$cant\_iters\_sin\_sol\_greedy\_rand\_factible\geq bad\_rgreedy\_its$}
	    	    		\If{$tipo\_golosa == por\_cantidad$}
	    	    		\Comment Maximo de its de greedy sin Solucion
	    	    	            \If{$parametro\_beta\geq2$}
	    	    	            	\Comment Ajustamos parametros de GRASP
	    	    	                \State $parametro\_beta--$
	    	    	            \EndIf
	    	    	    \ElsIf{$tipo\_golosa == por\_valor$}
	
	        	    	\State $parametro_beta = 0$
	        		\EndIf
	        		\State $cant\_iters\_sin\_sol\_greedy\_rand\_factible = 0$
	        	\EndIf
        	\EndIf
        \Else
        \Comment No hay Solucion
        	\State $break$
        \EndIf	
    \If{$criterio\_terminacion == 1$}
    \Comment{Si se cumple el criterio de terminacion}
           \State $condicion\_terminacion = (cant\_iters < max\_its)$            
        \ElsIf{$criterio\_terminacion == 2$}
            \State $condicion_terminacion = (cant\_iters\_sin\_mejora < max\_its\_sin\ _mejora)$
        \EndIf

       \EndWhile

       \State $return\:  mejor\_solucion$

\EndProcedure
\end{algorithmic}


\subsection{An\'alisis de complejidad}

