\section{Ap\'endice: Framework de Benchmarking} \label{casos_de_prueba}
\subsection{Descripcion de los metodos de benchmarking utilizados y presentacion de graficos}
\subsection{Resultados}
\subsubsection{Algoritmo exacto para la resolucion de CACM}
\subsubsection{Heuristicas constructivas golosas I: En cada paso tomar el minimo f2 dentro de las soluciones factibles(con f1 acotada)}
\subsubsection{Heuristicas constructivas golosas II: En cada paso tomar el minimo cociente de f1/f2 dentro de las soluciones factibles(con f1 acotada)}
\subsubsection{Heuristicas de busqueda local}
\subsubsection{Metaheuristica GRASP: Solucion propuesta}
%Para el testeo de los algoritmos y la medici\'on de tiempos en funci\'on de la entrada, se program\'o una utilidad para generar los casos de prueba.
%
%Los n\'umeros aleatorios que se generaron en los casos, se hizo con la funci\'on \emph{random()} de C ( \href{http://linux.die.net/man/3/random}{http://linux.die.net/man/3/random} ) usando como semilla el tiempo en microsegundos.

%Para el ejercicio 2, se le indica al programa la cantidad de ciudades, la cual se fue incrementando para la medici\'on del tiempo, y la cantidad de centrales se indicaba como un n\'umero aleatorio entre 1 y la cantidad de ciudades.

%As\'i se crearon muchos casos donde se fue incrementando el tama\~no de la entrada y ejecutando varios tests de un mismo tama\~no y varias veces el mismo test para obtener un promedio del tiempo que tarda en resolvero y descartar algunas imperfecciones que puedan surgir por el entorno donde se est\'a midiendo los tiempos, como puede ser que justo se ejecute otra tarea.

%Para los ejercicios 1 y 3, se programaron dentro de las clases Main de los diferentes ejercicio diferentes metodos que se encargan de la codificacion y decodificacion de entrada y salida tanto como de la generacion de tests aleatorios con distribucion uniforme. Se indica por parametro al ejecutable que se desea realizar.