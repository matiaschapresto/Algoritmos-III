\section{Heur\'istica Golosa}
\subsection{Explicacion detallada de la heur\'istica propuesta}

La heur\'istica consta de dos etapas: una etapa de inicializaci\'on y luego el algoritmo goloso propiamente dicho.

\subsubsection{Inicializaci\'on}

La etapa de inicializaci\'on consta en calcular los caminos m\'inimos en cuanto a costo $w_1$ de todos los nodos hacia el nodo de llegada. Ya que el grafo es simple, las aristas no tienen orientaci\'on definida, por lo cual dados dos nodos $v_1$ y $v_2$, el camino de $v_1$ a $v_2$ es igual al camino de $v_2$ a $v_1$. Esto nos permite ejecutar una \'unica vez el algoritmo de Dikjstra desde el nodo de llegada hasta todos los dem\'as y obtener lo buscado.

\vspace{2mm}

Una vez obtenidos los caminos m\'inimos de cada nodo a la llegada en cuanto a costo $w_1$, \'estos nos permiten conocer lo siguiente:

\begin{enumerate}
\item Al iniciar el algoritmo, aquellos nodos para las cuales no existe un camino de longitud $w_1 \leq K$ hasta el nodo llegada, los cuales nuestro algoritmo va a ignorar.
\item En medio de la ejecuci\'on del algoritmo, llamando $W_{ac}$ a la acumulac\'on de costos $w_1$ del camino recorrido por el algoritmo hasta ahora, puedo saber si el nodo $x$ de la pro\'oxima arista $(v,x$) a elegir tiene al menos un camino $c$ hasta el nodo llegada tal que, el costo del camino formado por la uni\'on de $c$ y el recorrido hasta ahora es $\leq K$. En caso de no tenerlo, desde ese nodo no hay un camino v\'alido hasta la llegada, por lo tanto nuestro algoritmo va a descartar esta arista y elegir alguna que tenga al menos un camino posible hasta la llegada. Esto lo podemos conocer, ya que la ejecuci\'on de Dijkstra inicial nos brinda el costo $w_1$ del camino m\'inimo desde el nodo $x$ hasta la llegada, por lo tanto  si $W_{ac}$ + $(v,x)$ + $longMinimoCamino(x,llegada)$ $\leq$ $K$ sabemos que existe al menos este camino v\'alido, caso contrario descartamos la arista.
\end{enumerate}


\begin{center}
\includegraphics[scale=0.58]{img/inicializacion.png}
\end{center}
\vspace{2mm}

Este dibujo representa la ejecuci\'on de la inicializaci\'on de la heur\'stica, donde el algoritmo de Dijkstra calcula los costos $w_1$ de los caminos m\'inimos de todos los nodos al nodo llegada (en violeta), y puede verse que aquellos nodos con caminos de costo mayor a $K$ ser\'an descartados.

\vspace{10mm}

Esto nos brinda una propiedad invariante: sabemos que en cada iteraci\'on, el costo acumulado del recorrido hecho es menor a $K$, y si al menos existe alg\'un un camino de costo menor a $K$ de salida a destino, el algoritmo muy probablemente va a poder llegar al nodo de llegada (excepto en casos enunciados en la siguiente secci\'on). Deducimos esto al considerar que, o bien no existe ning\'un camino y  el algoritmo termina en la primera iteraci\'on o el algoritmo elige una primera arista (por lo tanto existe un camino). 

\vspace{2mm}

Si el algoritmo elige una primera arista, pero luego no logra llegar a destino, significa (excepto en casos enunciados en la siguiente secci\'on) que en alg\'un punto, desde un nodo $v$ no encontr\'o ninguna arista $(v,x)$ tal que $W_{ac}$ + $(v,x)$ + $longMinimoCamino(x, llegada)$ $\leq$ $K$. Pero esto no puede ocurrir, ya que en la anterior iteraci\'on, tuvo que elegir necesariamente alguna arista con un extremo en $v$, y la elecci\'on de $v$ en la anterior iteraci\'on nos aseguraba que desde $v$ existe alg\'un camino v\'alido hasta la llegada, lo cual es absurdo porque el algoritmo se detuvo cuando lleg\'o a $v$. De esta forma concluimos en que, si existe algu\'n camino v\'alido desde la salida hasta la llegada, entonces nuestro algoritmo en la mayori\'a de los casos va a tener como salida un camino v\'alido (a desarrollar en la secci\'on siguiente).

\subsubsection{Algoritmo goloso}

A continuaci\'on se ejecuta el ciclo principal del algoritmo, que genera el CACM usando una heur\'istica golosa. Luego de la ejecuc\'on inicial del algoritmo de Dijkstra, el ciclo principal comienza en el nodo salida y realiza una elecci\'on golosa, la cual es: desde el nodo $v$, descartar las aristas $(v,x)$ incidentes en $v$ tal que $W_{ac}$ + $ss$ + $longMinimoCamino(x,llegada)$ > $K$. Entre las aristas que quedan, escoger la de menor costo $w_1$.(Aqu\'i se encuentra la desici\'on golosa). El algoritmo itera hasta alcanzar el nodo llegada.

\subsection{Pseudoc\'odigo}

\begin{algorithmic}

\Procedure{$Sol\_Golosa$}{$Grafo\: g, \:vertice\: v_1,\: vertice \: v_2, \: int \: k$}{$\rightarrow lista<eje>\: camino$}

\State $vector<int> \: distancias[g.\#nodos]$
\Comment $ O(n) $
\State $ Dijkstra( g, v_2, distancias) $
\Comment $ O() $
\State $lista<eje> \: camino= \emptyset$
\Comment $ O(1) $
\State $ int \: costoCamino = 0 $
\Comment $ O(1) $
\State $ vertice \: v_{actual} = v_1 $
\Comment $ O(1) $
\While{ $ actual != v_2 \: || \: incidentes= \emptyset $ }
\Comment $ O(n) $
	\State $ list<eje> \: incidentes = incidentes(v_{actual}, g) $
	\Comment $ O(m) $
	\State $ eje \:	 minimo = cab(incidentes) $
	\Comment $ O(m) Para\: evitar \:que \:cicle $
	\For {each $(u,v) \in \: incidentes$}
	\Comment $ O(m) $
		\If {$ distancias(v) + costoCamino \leq k \: \&\& \: costo2(u,v) \leq minimo$}
		\Comment $ O(1) $
			\State $ minimo = (u,v) $
			\Comment $ O(1) $
		\EndIf
	\EndFor
	\State $ Agregar(minimo, camino) $
	\Comment $ O(1) $
	\State $ costoCamino \: += costo1(minimo) $
	\Comment $ O(1) $
	\State $ v_{actual} = v $
	\Comment $ O(1) $
\EndWhile
\State $ return \: camino $
\Comment $ O(1) $

\EndProcedure

\end{algorithmic}


\subsection{Nivel de optimalidad de las soluciones}

A continuaci\'on vamos a exponer casos en los que la heur\'istica es muy poco eficiente.
\subsubsection{Costos $w_1$ despreciables}

La heur\'istica se basa fuertemente en asegurarse de que el costo $w_1$ del camino encontrado efectivamente sea menor a $K$, y por esto, uno de sus principales fuertes es el descarte de aristas para los cuales no existen caminos v\'alidos. Pero, si los costos $w_1$ de las aristas son despreciables, es decir, sus valores son muy pequenos (no nulos), de tal forma que el costo de cualquier camino simple es siempre menor a $K$, el algoritmo entero se reduce a la elecci\'on golosa de, en cada iteraci\'on, elegir la arista incidente de menor peso y agregarla al camino. Esto puede traer consecuencias como \'esta:

\begin{center}
\includegraphics[scale=0.7]{img/grafoCaminoMasLargo.png}
\end{center}
\vspace{2mm}

La familia de grafos en la cual para todo camino simple en el grafo su costo $w_1$ es siempre menor a $k$. En estos casos el m\'etodo de desici\'on y descarte del algoritmo es inefectivo y s\'olo prima la desici\'on golosa. Vemos en este grafo, que el camino formado por la elecci\'on de las aristas de menor coste $w_2$ (en color rojo) desde la salida tiene un coste final $w_2$ m\'as alto que el camino \'optimo (en verde). Los n\'umeros junto a cada arista son los costos $w_2$, y omitimos los costos $w_1$.

\vspace{2mm}

Hay que destacar que podr\'ia generarse un grafo con una suceci\'on arbitrariamente larga de nodos tal que para cada nodo, la arista de menor peso $w_2$ lo lleve al siguiente y evitar de esta forma que el algoritmo encuentre el nodo llegada hasta el final de la suceci\'on. De esta forma, podemos generarnos grafos de esta familia en los cuales la soluci\'on de nuestra heur\'stica est\'a tan lejos de la \'optima como queramos (sin pasarse de la cota $K$).


\begin{center}
\includegraphics[scale=0.35]{img/grafoChoto.png}
\end{center}

\subsubsection{Costos $w_1$ nulos}

En el caso de que algunas o todas aristas aristas tengan costos $w_1$ nulos, no s\'olo es inefectiva la inicializaci\'on sino que tambi\'en se pierde la certeza de si el algoritmo va a llegar efectivamente a destino, ya que en ning\'un momento hay un impedimento para seguir recorriendo arbitrariamente el grafo (cuando, en el caso en que los costos son no nulos, el hecho de ir acumulando costo $w_1$ necesariamente restring\'ia en alg\'un punto los caminos a tomar a aquellos que llegaban al destino con costo menor a $K$).

\vspace{2mm}

Podemos ver en un ejemplo c\'omo si el grafo posee un conjunto de nodos, tal que sus aristas de menor peso $w_2$ formen un ciclo entre ellos, el algoritmo podr\'a quedarse ciclando infinitamente y no llegar al destino.

\begin{center}
\includegraphics[scale=0.35]{img/ciclo.png}
\end{center}


\section{Heur\'istica Golosa Mejorada}

\subsection{Explicacion detallada de la heur\'istica propuesta}

Para solucionar estos problemas agregamos un BFS

\subsection{Pseudoc\'odigo}


\begin{algorithmic}

\Procedure{$Sol\_Golosa$}{$Grafo\: g, \:vertice\: v_1,\: vertice \: v_2, \: int \: k$}{$\rightarrow lista<eje>\: camino$}

\State $vector<int> \: distancias[g.\#nodos]$
\Comment $ O(n) $
\State $ Dijkstra( g, v_2, distancias) $
\Comment $ O() $
\State $lista<eje> \: camino= \emptyset$
\Comment $ O(1) $
\State $ int \: costoCamino = 0 $
\Comment $ O(1) $
\State $ visitadas[v_1] = true $
\Comment $ O(1) $
\State $ vertice \: v_{actual} = v_1 $
\Comment $ O(1) $
\While{ $ actual != v_2 \: || \: incidentes= \emptyset $ }
\Comment $ O(n) $
	\State $ list<eje> \: incidentes = incidentes(v_{actual}, g) $
	\Comment $ O(m) $
	\State $ eje \:	 minimo = cab(incidentes) $
	\Comment $ O(m) Para\: evitar \:que \:cicle $
	\For {each $(u,v) \in \: incidentes$}
	\Comment $ O(m) $
		\If {$ distancias(v) + costoCamino \leq k \: \&\& \: costo2(u,v) \leq minimo$}
		\Comment $ O(1) $
			\State $ minimo = (u,v) $
			\Comment $ O(1) $
		\EndIf
	\EndFor
	\State $ Agregar(minimo, camino) $
	\Comment $ O(1) $
	\State $ costoCamino \: += costo1(minimo) $
	\Comment $ O(1) $
	\State $ v_{actual} = v $
	\Comment $ O(1) $
\EndWhile
\State $ return \: camino $
\Comment $ O(1) $

\EndProcedure

\end{algorithmic}




\subsection{Complejidad temporal para el peor caso}

La inicializaci\'on ejecuta el algoritmo de Dijkstra, que tiene una complejidad de $O(n^2)$ . El ciclo goloso del algoritmo itera hasta que el v\'ertice actual es igual al v\'ertice de llegada, y recorre como m\'aximo una vez cada v\'ertice (dado el vector visitados), por lo tanto tiene complejidad $O(n)$. Al iniciar el ciclo se ejecuta la funci\'on $incidentes$ que recorre las aristas incidentes en el v\'ertice $actual$, como m\'aximo puede haber $m$ aristas por lo tanto tiene complejidad $O(m)$, y se ejecuta un ciclo $for$ que recorre estas aristas incidentes, por lo tanto tambi\'en $\in$ $O(n)$. Esto nos da una complejidad final de = $ O(n^2)+ O(n)*(O(m)+O(m)) = O(nm)$. 

en realidad depende de la distancia en saltos de salida a llegada que esta acotada tambien por en ;).