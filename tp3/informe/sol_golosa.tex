\section{Heur\'istica Golosa}
\subsection{Explicacion detallada del algoritmo propuesto}

El algoritmo propuesto consta de dos etapas: una etapa de inicializaci\'on y luego el algoritmo goloso propiamente dicho.

\subsubsection{Inicializaci\'on}

Nuestra etapa de inicializaci\'on consta en calcular los caminos m\'inimos en cuanto a costo $w_1$ de todos los nodos hacia el nodo de llegada. Ya que el grafo es simple, las aristas no tienen orientaci\'on definida, por lo cual dados dos nodos $v_1$ y $v_2$, el camino de $v_1$ a $v_2$ es igual al camino de $v_2$ a $v_1$. Esto nos permite ejecutar una \'unica vez el algoritmo de Dikjstra desde el nodo de llegada hasta todos los dem\'as y obtener lo buscado.

\vspace{2mm}

Una vez obtenidos los caminos m\'inimos en cuanto a costo $w_1$, \'estos nos permiten conocer lo siguiente:

\begin{enumerate}
\item Al iniciar el algoritmo, aquellos nodos para los cuales no existe un camino de longitud $w_1 \leq K$ hasta el nodo llegada, los cuales nuestro algoritmo va a ignorar.
\item En medio de la ejecuci\'on del algoritmo, llamando $W_{ac}$ a la acumulac\'on de costos $w_1$ del camino recorrido por el algoritmo hasta ahora, puedo saber si el nodo de la pro\'oxima arista a elegir tiene al menos un camino $c$ hasta el nodo llegada tal que, el costo del camino formado por la uni\'on de $c$ y el recorrido hasta ahora es $\leq K$. En caso de no tenerlo, desde ese nodo no hay un camino v\'alido hasta la llegada, por lo tanto nuestro algoritmo va a descartar esta arista y elegir alguna que tenga al menos un camino posible hasta la llegada. Esto lo podemos conocer, ya que la ejecuci\'on de Dijkstra inicial nos brinda el costo $w_1$ del camino m\'inimo desde el nodo hasta la llegada, por lo tanto  si $W_{ac}$ + $arista$ + $long(minimoCamino)$ $\leq$ $K$ sabemos que existe al menos este camino v\'alido, caso contrario descartamos el nodo.
\end{enumerate}


\begin{center}
\includegraphics[scale=0.6]{inicializacion.png}
\end{center}
\vspace{2mm}



Esto nos brinda una propiedad invariante: sabemos que en cada iteraci\'on, el costo acumulado del recorrido hecho es necesariamente menor a $K$, y si al menos existe alg\'un un camino de costo menor a $K$ de salida a destino, el algoritmo necesariamente va a poder llegar al nodo de llegada. Deducimos esto al considerar que, o bien no existe ning\'un camino y  el algoritmo termina en la primera iteraci\'on (ya que Dijkstra indica que los caminos m\'inos de costo $K$ de todos los nodos adyacentes a la salida son mayores a $K$, por lo tanto no hay nodo que elegir), o el algoritmo elige una primera arista (por lo tanto existe un camino). 

\vspace{2mm}

Si el algoritmo elige una primera arista, pero luego no logra llegar a destino, significa que en alg\'un punto, desde un nodo $v$ no encontr\'o ninguna arista tal que $W_{ac}$ + $arista$ + $long(minimoCamino)$ $\leq$ $K$. Pero esto no puede ocurrir, ya que en la anterior iteraci\'on, tuvo que elegir necesariamente alguna arista con un extremo en $v$, y el invariante del algortimo nos asegura que desde $v$ existe alg\'un camino v\'alido hasta la llegada, lo cual es absurdo porque el algoritmo se detuvo cuando lleg\'o a $v$. De esta forma concluimos en que, si existe algu\'n camino v\'alido desde la salida hasta la llegada, entonces nuestro algoritmo siempre va a tener como salida un camino v\'alido.

\subsubsection{Algoritmo goloso}

A continuaci\'on se ejecuta el ciclo principal del algoritmo, que genera el CACM usando una heur\'istica golosa. Luego de la ejecuc\'on inicial del algoritmo de Dijkstra, el ciclo principal comienza en el nodo salida y realiza una elecci\'on golosa, la cual es: desde el nodo $v$, descartar las aristas $(v,x)$ incidentes en $v$ tal que $W_{ac}$ + $ss$ + $long(minimoCamino(x))$ $\geq$ $K$. Entre las aristas que quedan, escoger la de menor costo $w_1$.(Aqu\'i se encuentra la desici\'on golosa). El algoritmo itera hasta alcanzar el nodo llegada.

\subsection{Pseudoc\'odigo}


\begin{algorithmic}

\Procedure{$Sol\_Golosa$}{$Grafo\: g, \:vertice\: v_1,\: vertice \: v_2, \: int \: k$}{$\rightarrow lista<eje>\: camino$}

\State $vector<int> \: distancias[g.\#nodos]$
\Comment $ O(n) $
\State $vector<bool> \: visitadas[g.\#aristas]$
\Comment $ O(n) $
\State $ Dijkstra( g, v_2, distancias) $
\Comment $ O() $
\State $lista<eje> \: camino= \emptyset$
\Comment $ O(1) $
\State $ int \: costoCamino = 0 $
\Comment $ O(1) $
\State $ visitadas[v_1] = true $
\Comment $ O(1) $
\State $ vertice \: v_{actual} = v_1 $
\Comment $ O(1) $
\While{ $ actual != v_2 \: || \: incidentes= \emptyset $ }
\Comment $ O(n) $
	\State $ list<eje> \: incidentes = incidentes(v_{actual}, g) $
	\Comment $ O(m) $
	\State $ eje \:	 minimo = primeraNoVisitada(incidentes) $
	\Comment $ O(m) Para\: evitar \:que \:cicle $
	\For {each $(u,v) \in \: incidentes$}
	\Comment $ O(m) $
		\If {$ distancias(v) + costoCamino \leq k \: \&\& \: costo2(u,v) \leq minimo\: \&\& \: visitadas[(u,v)] = false $}
		\Comment $ O(1) $
			\State $ minimo = (u,v) $
			\Comment $ O(1) $
		\EndIf
	\EndFor
	\State $ Agregar(minimo, camino) $
	\Comment $ O(1) $
	\State $ costoCamino \: += costo1(minimo) $
	\Comment $ O(1) $
	\State $ v_{actual} = v $
	\Comment $ O(1) $
\EndWhile
\State $ return \: camino $
\Comment $ O(1) $

\EndProcedure

\end{algorithmic}
\subsection{Complejidad temporal para el peor caso}

La inicializaci\'on ejecuta el algoritmo de Dijkstra, que tiene una complejidad de el nene . El ciclo goloso del algoritmo itera hasta que el v\'ertice actual es igual al v\'ertice de llegada, y recorre como m\'aximo una vez cada v\'ertice (dado el vector visitados), por lo tanto tiene complejidad $O(n)$. Al iniciar el ciclo se ejecuta la funci\'on $incidentes$ que recorre las aristas incidentes en el v\'ertice $actual$, como m\'aximo puede haber $m$ aristas por lo tanto tiene complejidad $O(m)$, y se ejecuta un ciclo $for$ que recorre estas aristas incidentes, por lo tanto tambi\'en $\in$ $O(n)$. Esto nos da una complejidad final de = $ O(el nene)+ O(n)*(O(m)+O(m)) = O(nm)$. 

\subsection{Nivel de optimalidad de las soluciones}

A continuaci\'on vamos a exponer casos en los que la heur\'istica es muy poco eficiente.
\subsubsection{Costos $w_1$ despreciables}

Nuestra heur\'istica se basa fuertemente en asegurarse de que el camino encontrado efectivamente llegue al v\'ertice final, y que el costo $w_1$ acumulado sea menor a $k$, y por esto, uno de sus principales fuerets es el descarte de aristas para los cuales no existen caminos v\'alidos. Pero, si los costos $w_1$ de las aristas son despreciables, es decir, sus valores son muy pequenos (no nulos), de tal forma que el costo de cualquier camino que no repite v\'ertices es siempre menor a $K$, el algoritmo entero se reduce a la elecci\'on golosa de, en cada iteraci\'on, elegir la arista incidente de menor peso y agregarla al camino. Esto puede traer consecuencias como \'esta:

\begin{center}
\includegraphics[scale=0.7]{grafoCaminoMasLargo.png}
\end{center}
\vspace{2mm}

La familia de grafos en la cual para todo camino entre dos nodos (que no repita v\'ertices) su costo $w_1$ es siempre menor a $k$. En estos casos el m\'etodo de desici\'on y descarte del algoritmo es inefectivo y s\'olo prima la desici\'on golosa. Vemos en este grafo, que las aristas de menor coste $w_2$ (en color rojo) forman una suceci\'on con un coste final $w_2$ m\'as alto que el camino \'optimo (en verde). Los n\'umeros junto a cada arista son los costos $w_1$, y omitimos los costos $w_2$.

\vspace{2mm}

Hay que destacar que podr\'ia generarse un grafo con una suceci\'on arbitrariamente larga de aristas tal que para cada nodo, la arista de menor peso $w_2$ pertenezca a ella, y que la \'unica arista que incida en el v\'ertice de llegada sea la \'ultima. De esta forma, podemos generarnos grafos de esta familia en los cuales la soluci\'on de nuestra heur\'stica est\'a tan lejos de la \'optima como queramos. De todas formas, el algoritmo nunca se va a quedar ciclando infinitamente, ya que como los costos son no nulos, en alg\'un punto el algoritmo va a descartar la arista que lo lleva de nuevo al ciclo ya que el costo $w_1$ del ciclo + el del camino recorrido ya no va a ser menor o igual a $k$.

\subsubsection{Costos $w_1$ nulos}

En el caso de que las aristas tengan costos $w_1$ nulos, y halla en el grafo un ciclo de pesos $w_2$ m\'inimos el algoritmo no va a terminar.	